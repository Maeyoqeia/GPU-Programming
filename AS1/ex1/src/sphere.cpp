/// @file
////////////////////////////////////////////////////////////////////////////////////////////////////
///
/// Copyright (C) 2016/17      Christian Lessig, Otto-von-Guericke Universitaet Magdeburg
///
////////////////////////////////////////////////////////////////////////////////////////////////////
///
///  module     : Exercise 1
///
///  author     : lessig@isg.cs.ovgu.de
///
///  project    : GPU Programming
///
///  description: sphere
///
////////////////////////////////////////////////////////////////////////////////////////////////////

// includes, file
#include "sphere.h"

// includes, project
#include "util.h"

// includes, system
#include <iostream>

////////////////////////////////////////////////////////////////////////////////////////////////////
// constructor, default
////////////////////////////////////////////////////////////////////////////////////////////////////
Sphere::Sphere( std::shared_ptr<Material> m) :
  Geometry( m),
  r( 0.0)
{ }

////////////////////////////////////////////////////////////////////////////////////////////////////
// constructor, copy
////////////////////////////////////////////////////////////////////////////////////////////////////
Sphere::Sphere( const Sphere& other) :
  Geometry( other),
  r( other.r)
{ }

////////////////////////////////////////////////////////////////////////////////////////////////////
// destructor
////////////////////////////////////////////////////////////////////////////////////////////////////
Sphere::~Sphere() { };

////////////////////////////////////////////////////////////////////////////////////////////////////
// compute intersection
////////////////////////////////////////////////////////////////////////////////////////////////////
bool
Sphere::intersect( Ray& ray /*ray*/, Intersection& intersec/*intersec*/) const {

  // TODO: compute intersection point
    vec3 center = this->pos;
    vec3 origin = ray.origin;
    vec3 dir = ray.dir;
    //test whether discriminant is less than zero

    vec3 a = origin-this->pos;
    float b = (dot(ray.dir, a));

    float dis = b*b - (Util::norm(a)*Util::norm(a)) + r*r;

        if(dis >= 0){
            float t01 = -b + sqrt(dis);
            float t02 = -b - sqrt(dis);
            float t = min(t01,t02);
            if(t < ray.t && t > 0){
                ray.t =t;
                intersec.pos = ray();
                intersec.mat = mat;
                intersec.n = intersec.pos - this->pos;
                intersec.n /= Util::norm(intersec.n);
                intersec.w_out = ray.origin - intersec.pos;
                intersec.w_out /= Util::norm(intersec.w_out);
                return true;
            }
         }

        return false;


}
